#!/usr/bin/env python3
import sys, time, os, math, zlib, logging
import chess, chess.polyglot, chess.syzygy

# === Logging Setup ===
logging.basicConfig(filename='engine.log', level=logging.INFO)
logger = logging.getLogger(__name__)

# === UCI Config Options ===
uci_options = {
    "Threads": 1,
    "Hash": 128,
    "Move Overhead": 100,
    "Max Nodes": 0,
    "BookPath": "book.bin",
    "SyzygyPath": "syzygy"
}

# === Constants ===
MAX_DEPTH = 64
MATE_VALUE = 100000
TIME_LIMIT = 3.0
LMR_BASE = 0.75
LMR_DIVISOR = 2.0

# === Global State ===
transposition_table = {}
pawn_hash_table = {}
history_heuristic = {}
killer_moves = [[None]*2 for _ in range(100)]
node_count = 0
NODE_LIMIT = None
polyglot_book = None
syzygy_tb = None

# === Piece Values (MG/EG) ===
PIECE_VALUES = {
    chess.PAWN: [100, 120],
    chess.KNIGHT: [320, 350],
    chess.BISHOP: [330, 360],
    chess.ROOK: [500, 600],
    chess.QUEEN: [900, 1100],
    chess.KING: [20000, 20000]
}

# === Piece-Square Tables (MG/EG) ===
PST = {
    chess.PAWN: [[0, 5, 5, 0, 5, 10, 50, 0] * 8, [0]*64],
    chess.KNIGHT: [[-50, -40, -30, -30, -30, -30, -40, -50] * 8, [0]*64],
    chess.BISHOP: [[-20, -10, -10, -10, -10, -10, -10, -20] * 8, [0]*64],
    chess.ROOK: [[0, 0, 5, 10, 10, 5, 0, 0] * 8, [0]*64],
    chess.QUEEN: [[-20, -10, -10, -5, -5, -10, -10, -20] * 8, [0]*64],
    chess.KING: [[20, 30, 10, 0, 0, 10, 30, 20] * 8, [0]*64]
}

# === Evaluation Parameters ===
BISHOP_PAIR = [30, 50]  # MG, EG
ROOK_OPEN_FILE = [15, 25]
KNIGHT_OUTPOST = [20, 30]
PASSED_PAWN = [[0, 10, 30, 50, 75, 100, 150], [0, 20, 40, 70, 120, 200, 300]]  # MG, EG

def game_phase(board):
    phase = 0
    for piece in [chess.KNIGHT, chess.BISHOP, chess.ROOK, chess.QUEEN]:
        phase += len(board.pieces(piece, chess.WHITE)) + len(board.pieces(piece, chess.BLACK))
    return min(phase * 16, 256)

def interpolate(mg, eg, phase):
    return (mg * (256 - phase) + eg * phase) // 256

def evaluate_pawn_structure(board, color, pawn_hash):
    hash_key = zlib.crc32(str(sorted(board.pieces(chess.PAWN, color))).encode())
    if hash_key in pawn_hash:
        return pawn_hash[hash_key]

    score = 0
    pawns = board.pieces(chess.PAWN, color)
    for sq in pawns:
        rank = chess.square_rank(sq)
        file = chess.square_file(sq)
        forward = range(rank + 1, 8) if color == chess.WHITE else range(rank - 1, -1, -1)
        passed = True
        for r in forward:
            for f in [file - 1, file, file + 1]:
                if 0 <= f < 8:
                    if board.piece_at(chess.square(f, r)) == chess.Piece(chess.PAWN, not color):
                        passed = False
        if passed:
            score += PASSED_PAWN[0 if color == chess.WHITE else 1][rank if color == chess.WHITE else 7 - rank]

    pawn_hash[hash_key] = score
    return score

def evaluate(board):
    phase = game_phase(board)
    score = 0
    for pt in PIECE_VALUES:
        white = len(board.pieces(pt, chess.WHITE))
        black = len(board.pieces(pt, chess.BLACK))
        score += interpolate(PIECE_VALUES[pt][0], PIECE_VALUES[pt][1], phase) * (white - black)
        for sq in board.pieces(pt, chess.WHITE):
            score += interpolate(PST[pt][0][sq], PST[pt][1][sq], phase)
        for sq in board.pieces(pt, chess.BLACK):
            mirror_sq = chess.square_mirror(sq)
            score -= interpolate(PST[pt][0][mirror_sq], PST[pt][1][mirror_sq], phase)

    score += evaluate_pawn_structure(board, chess.WHITE, pawn_hash_table)
    score -= evaluate_pawn_structure(board, chess.BLACK, pawn_hash_table)

    return score if board.turn == chess.WHITE else -score

def is_quiet(board, move):
    return not board.is_capture(move) and not board.gives_check(move)

def alpha_beta(board, depth, alpha, beta, start_time, max_time, ply=0, can_null=True):
    global node_count
    if time.time() - start_time > max_time:
        raise TimeoutError

    if depth == 0:
        return evaluate(board)

    moves = list(board.legal_moves)
    best_score = -float("inf")

    for i, move in enumerate(sorted(moves, key=lambda m: history_heuristic.get((board.piece_at(m.from_square), m.to_square), 0), reverse=True)):
        board.push(move)
        node_count += 1

        if i >= 3 and depth >= 3 and is_quiet(board, move):
            reduction = int(math.log(i + 1) * LMR_BASE + LMR_DIVISOR)
            reduced_depth = max(1, depth - 1 - reduction)
            score = -alpha_beta(board, reduced_depth, -beta, -alpha, start_time, max_time, ply + 1)
        else:
            score = -alpha_beta(board, depth - 1, -beta, -alpha, start_time, max_time, ply + 1)

        board.pop()

        if score > best_score:
            best_score = score
        if best_score > alpha:
            alpha = best_score
        if alpha >= beta:
            break

    return best_score

def choose_best_move(board, depth=None, nodes=None, wtime=None, btime=None, winc=None, binc=None, movestogo=None):
    global node_count
    node_count = 0
    best_move = None
    best_score = -float("inf")
    start_time = time.time()
    max_time = TIME_LIMIT
    max_depth = depth or MAX_DEPTH

    legal_moves = list(board.legal_moves)
    if not legal_moves:
        return None
    best_move = legal_moves[0]

    try:
        for d in range(1, max_depth + 1):
            for move in legal_moves:
                board.push(move)
                score = -alpha_beta(board, d - 1, -MATE_VALUE, MATE_VALUE, start_time, max_time)
                board.pop()
                if score > best_score:
                    best_score = score
                    best_move = move
                if best_score >= MATE_VALUE - 100:
                    return best_move
            if time.time() - start_time > max_time * 0.9:
                break
    except TimeoutError:
        pass

    return best_move

def main():
    board = chess.Board()
    while True:
        line = sys.stdin.readline()
        if not line:
            break
        line = line.strip()
        if line == "uci":
            print("id name SupraTapered")
            print("id author Suprateem")
            print("uciok")
        elif line == "isready":
            print("readyok")
        elif line.startswith("position"):
            parts = line.split()
            if "startpos" in parts:
                board.reset()
                if "moves" in parts:
                    for mv in parts[parts.index("moves") + 1:]:
                        board.push_uci(mv)
            elif "fen" in parts:
                idx = parts.index("fen")
                fen = " ".join(parts[idx + 1:idx + 7])
                board.set_fen(fen)
                if "moves" in parts:
                    for mv in parts[parts.index("moves") + 1:]:
                        board.push_uci(mv)
        elif line.startswith("go"):
            move = choose_best_move(board)
            print("bestmove", move.uci() if move else "0000")
        elif line == "quit":
            break
        sys.stdout.flush()

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        logger.exception("Engine crashed")
        print(f"info string Engine error: {e}")
        sys.exit(1)
